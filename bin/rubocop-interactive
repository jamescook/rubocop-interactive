#!/usr/bin/env ruby
# frozen_string_literal: true

# Load our gem dependencies BEFORE bundler/setup to avoid Ruby 3.4 bundled_gems issues
require 'diff/lcs'

# Use project's bundled gems if available (respects Gemfile.lock versions for rubocop)
begin
  require 'bundler/setup'
rescue LoadError
  # Bundler not available, use system gems
rescue Bundler::GemfileNotFound
  # No Gemfile in project, use system gems
end

require 'optparse'
require_relative '../lib/rubocop_interactive'

# Handle Ctrl+C gracefully - twice in quick succession exits
last_interrupt = nil
trap('INT') do
  if last_interrupt && (Time.now - last_interrupt) < 1.0
    puts "\nExiting..."
    exit 0
  else
    last_interrupt = Time.now
    puts "\nPress Ctrl+C again to exit"
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: rubocop-interactive [options] [file ...]'
  opts.separator ''
  opts.separator 'Examples:'
  opts.separator '  rubocop-interactive file.rb              # Run rubocop on file.rb'
  opts.separator '  rubocop --format json | rubocop-interactive  # Pipe from rubocop'
  opts.separator '  rubocop-interactive --rubocop "bundle exec rubocop" lib/'
  opts.separator ''

  opts.on('--confirm-patch', 'Show patch preview before applying corrections') do
    options[:confirm_patch] = true
  end

  opts.on('--template NAME', 'Use a specific template (default, compact, or path to .erb)') do |name|
    options[:template] = name
  end

  opts.on('--rubocop COMMAND', 'RuboCop command to use (default: rubocop)') do |cmd|
    RubocopInteractive.config.rubocop_binary = cmd
  end

  opts.on('--debug-preserve-temp', 'Preserve temp file states for debugging') do
    RubocopInteractive.config.debug_preserve_temp = true
  end

  opts.on('--summary-on-exit [BOOL]', TrueClass, 'Show summary on exit (default: false)') do |bool|
    options[:summary_on_exit] = bool.nil? || bool
  end

  # Undocumented option for recording keypresses (test development only)
  opts.on('--record', 'Record keypresses to timestamped log file') do
    options[:record_keypresses] = true
  end

  opts.on('--version', 'Show version') do
    puts "rubocop-interactive version #{RubocopInteractive::VERSION}"
    exit
  end

  opts.on('--print-rubocop-version', 'Show which RuboCop version will be used') do
    require 'rubocop'
    puts "RuboCop version: #{RuboCop::Version.version}"
    puts "RuboCop path: #{Gem.loaded_specs['rubocop']&.full_gem_path || 'unknown'}"
    exit
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end
end.parse!

# Start interactive session - loading screen shown before reading input
input = ARGV.any? ? ARGV : $stdin
RubocopInteractive.start!(input, **options)
