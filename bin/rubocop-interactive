#!/usr/bin/env ruby
# frozen_string_literal: true

# Use project's bundled gems if available (respects Gemfile.lock versions)
begin
  require 'bundler/setup'
rescue LoadError
  # Bundler not available, use system gems
rescue Bundler::GemfileNotFound
  # No Gemfile in project, use system gems
end

require 'optparse'
require_relative '../lib/rubocop_interactive'

# Handle Ctrl+C gracefully - twice in quick succession exits
last_interrupt = nil
trap('INT') do
  if last_interrupt && (Time.now - last_interrupt) < 1.0
    puts "\nExiting..."
    exit 0
  else
    last_interrupt = Time.now
    puts "\nPress Ctrl+C again to exit"
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: rubocop-interactive [options] [file ...]'
  opts.separator ''
  opts.separator 'Examples:'
  opts.separator '  rubocop-interactive file.rb              # Run rubocop on file.rb'
  opts.separator '  rubocop --format json | rubocop-interactive  # Pipe from rubocop'
  opts.separator '  rubocop-interactive --rubocop "bundle exec rubocop" lib/'
  opts.separator ''

  opts.on('--confirm-patch', 'Show patch preview before applying corrections') do
    options[:confirm_patch] = true
  end

  opts.on('--template NAME', 'Use a specific template (default, compact, or path to .erb)') do |name|
    options[:template] = name
  end

  opts.on('--rubocop COMMAND', 'RuboCop command to use (default: rubocop)') do |cmd|
    RubocopInteractive.config.rubocop_binary = cmd
  end

  opts.on('--debug-preserve-temp', 'Preserve temp file states for debugging') do
    RubocopInteractive.config.debug_preserve_temp = true
  end

  opts.on('--summary-on-exit [BOOL]', TrueClass, 'Show summary on exit (default: false)') do |bool|
    options[:summary_on_exit] = bool.nil? ? true : bool
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end
end.parse!

# Get JSON either from file arguments or stdin
json = if ARGV.any?
         # Run rubocop on specified files using in-process API
         require 'rubocop'
         require 'stringio'

         output = StringIO.new
         old_stdout = $stdout
         old_stderr = $stderr
         $stdout = output
         $stderr = StringIO.new

         begin
           cli = RuboCop::CLI.new
           cli.run(['--format', 'json'] + ARGV)
         ensure
           $stdout = old_stdout
           $stderr = old_stderr
         end

         output.string
       else
         $stdin.read
       end

if json.empty?
  warn 'Usage: rubocop-interactive [file ...] or rubocop --format json | rubocop-interactive'
  exit 1
end

RubocopInteractive.start!(json, **options)
